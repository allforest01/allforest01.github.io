# SecurityValley CTF


<!--more-->

## Reversing

### Simple ELF

{{< admonition info >}}
Level: 1 Score 5 Category reversing  
Can you deal with dwarfs and elfs`  
Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/the_elf
{{< /admonition >}}

That is so easy, just look at `printFlag` function.  
Disassemble with Ghidra:

```asm
                      **************************************************************
                      *                          FUNCTION                          *
                      **************************************************************
                      undefined printFlag()
      undefined         AL:1           <RETURN>
      undefined8        Stack[-0x10]:8 local_10                       XREF[2]:    0010117c(W), 
                                                                                  00101180(R)  
                      printFlag                                       XREF[4]:    Entry Point(*), main:001011bf(c), 
                                                                                  001020b0, 00102150(*)  
00101169 f3 0f 1e fa     ENDBR64
0010116d 55              PUSH       RBP
0010116e 48 89 e5        MOV        RBP,RSP
00101171 48 83 ec 10     SUB        RSP,0x10
00101175 48 8d 05        LEA        RAX,[s_SecVal{cr4ck1n9_15_E45y}_00102008]        = "SecVal{cr4ck1n9_15_E45y}"
         8c 0e 00 00
0010117c 48 89 45 f8     MOV        qword ptr [RBP + local_10],RAX=>s_SecVal{cr4ck   = "SecVal{cr4ck1n9_15_E45y}"
00101180 48 8b 45 f8     MOV        RAX,qword ptr [RBP + local_10]
00101184 0f b6 00        MOVZX      EAX=>s_SecVal{cr4ck1n9_15_E45y}_00102008,byte    = "SecVal{cr4ck1n9_15_E45y}"
00101187 0f be c0        MOVSX      EAX,AL
0010118a 89 c6           MOV        ESI,EAX
0010118c 48 8d 05        LEA        RAX,[s_%c_Whoops,_that_was_weird??_00102028]     = "%c \nWhoops, that was weird??
         95 0e 00 00
00101193 48 89 c7        MOV        RDI=>s_%c_Whoops,_that_was_weird??_00102028,RAX  = "%c \nWhoops, that was weird??
00101196 b8 00 00        MOV        EAX,0x0
         00 00
0010119b e8 d0 fe        CALL       <EXTERNAL>::printf                               int printf(char * __format, ...)
         ff ff
001011a0 90              NOP
001011a1 c9              LEAVE
001011a2 c3              RET
```

{{< admonition success >}}
Flag: SecVal{cr4ck1n9_15_E45y}
{{< /admonition >}}

### No statics

{{< admonition info >}}
Level: 1 Score 10 Category reversing  
This time there is no static value inside...but you are the best. So crack it baby!  
Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/no_static
{{< /admonition >}}

Decompile with Ghidra:

```cpp

undefined8 main(void)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined8 local_3a;
  undefined local_32;
  char local_31 [9];
  undefined8 local_28;
  undefined8 local_20;
  undefined8 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("Again, there is something inside me!");
  local_28 = 0x5d84756a5f6c6e5c;
  local_20 = 0x683e6a60683e3a71;
  local_18 = 0x865b3c6d7b6a51;
  local_3a = 0x80717e6f715f8579;
  local_32 = 0;
  puts("enter your passphrase, please!");
  fgets(local_31,9,stdin);
  printf("try:%s ........ \n",local_31);
  prepare(&local_3a,0xc);
  printf("%s \n",&local_3a);
  iVar1 = strcmp(local_31,(char *)&local_3a);
  if (iVar1 == 0) {
    sleep(1);
    prepare(&local_28,9);
    printf("%s \n",&local_28);
  }
  else {
    puts("WRONG!");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

From the line 23, we assume that the password will have 8 chars in length.

```cpp
fgets(local_31,9,stdin);
```

From lines 25-26, we see that the `local_3a` will be generated by `prepare` function and then be printed.

```cpp
iVar1 = strcmp(local_31,(char *)&local_3a);
printf("%s \n",&local_3a);
```

From lines 27-30, the `local_3a` will be compared with our password. If two strings are equal the `local_28`, may be this is the flag we want.  
So just run this program and get it the flag.

```cpp
(debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ ./crackme-02
Again, there is something inside me!
enter your passphrase, please!
a
try:a
 ........ 
mySecret 
WRONG!
(debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ ./crackme-02
Again, there is something inside me!
enter your passphrase, please!
mySecret
try:mySecret ........ 
mySecret 
SecVal{Th15_Wa5_Hard3R} 
(debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ 
```

{{< admonition success >}}
Flag: SecVal{Th15_Wa5_Hard3R}
{{< /admonition >}}

### The loader

{{< admonition info >}}
Level: 3 Score 30 Category reversing  
I've seen that in malware before. There must be something inside  
Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/the_loader
{{< /admonition >}}

For this problem, it's easier to solve with dynamic analyst. First let decompile that:

```cpp
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  const char *Hop; // rax
  unsigned int v4; // [rsp+Ch] [rbp-14h] BYREF
  void *v5; // [rsp+10h] [rbp-10h]
  unsigned __int64 v6; // [rsp+18h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  v5 = &unk_2018;
  v4 = 0;
  while ( 1 )
  {
    adjustCounter(&v4, argv, envp);
    Hop = (const char *)getHop(v4);
    argv = (const char **)v4;
    printf("%d.%s \n\nWouldn't it be cool to be able to look into the memory?\n\n", v4, Hop);
    huuu(v5);
    ++v4;
    sleep(1u);
  }
}
```

Look like the problem is in `huuu()`

```cpp
__int64 __fastcall huuu(__int64 a1)
{
  __int64 str_size; // rax
  __int64 s_mem; // [rsp+18h] [rbp-8h]

  s_mem = load_s_mem(a1, 254LL);
  str_size = get_str_size(s_mem);
  return unload_mem(s_mem, str_size);
}
```

Maybe this function load an unload the flag, so let's set a breakpoint at the load_s_mem and view the memory.

{{< highlight cpp "hl_lines=13" >}}
void *__fastcall load_s_mem(const void *a1, char a2)
{
  int i; // [rsp+1Ch] [rbp-14h]
  unsigned __int64 size; // [rsp+20h] [rbp-10h]
  void *dest; // [rsp+28h] [rbp-8h]

  size = get_str_size(a1);
  dest = malloc(size);
  memcpy(dest, a1, size);
  for ( i = 0; size > i; ++i )
    *((_BYTE *)dest + i) ^= a2;
  *((_BYTE *)dest + size) = 0;
  return dest; // <- set a breakpoint here
}
{{< / highlight >}}

[This posts is currently being updated...]

